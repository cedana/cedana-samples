apiVersion: v1
kind: Pod
metadata:
  generateName: intel-mkl-bench-
  namespace: default
spec:
  restartPolicy: Never
  containers:
  - name: mkl-bench
    image: intel/oneapi-hpckit:2024.0.1-devel-ubuntu22.04
    resources:
      requests:
        cpu: "1"
        memory: "2Gi"
      limits:
        cpu: "4"
        memory: "16Gi"
    env:
    - name: OMP_NUM_THREADS
      value: "4"
    - name: MKL_NUM_THREADS
      value: "4"
    command:
    - bash
    - -c
    - |
      echo "============================================================"
      echo "Intel MKL Benchmark Suite"
      echo "============================================================"

      # Environment is pre-configured in this image
      echo "MKLROOT: $MKLROOT"
      echo "Threads: $OMP_NUM_THREADS"
      echo ""

      mkdir -p /tmp/mkl && cd /tmp/mkl

      cat > mkl_bench.c << 'CEOF'
      #include <stdio.h>
      #include <stdlib.h>
      #include <time.h>
      #include <math.h>
      #include <mkl.h>

      double get_time() {
          struct timespec ts;
          clock_gettime(CLOCK_MONOTONIC, &ts);
          return ts.tv_sec + ts.tv_nsec * 1e-9;
      }

      void bench_dgemm(int n, int iterations) {
          printf("\n[DGEMM] %dx%d matrix multiply (%d iterations)\n", n, n, iterations);
          fflush(stdout);

          double *A = (double*)mkl_malloc(n * n * sizeof(double), 64);
          double *B = (double*)mkl_malloc(n * n * sizeof(double), 64);
          double *C = (double*)mkl_malloc(n * n * sizeof(double), 64);

          if (!A || !B || !C) { printf("  Memory allocation failed\n"); return; }

          for (int i = 0; i < n * n; i++) {
              A[i] = (double)rand() / RAND_MAX;
              B[i] = (double)rand() / RAND_MAX;
              C[i] = 0.0;
          }

          double alpha = 1.0, beta = 0.0;

          // Warm-up
          cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                      n, n, n, alpha, A, n, B, n, beta, C, n);

          double start = get_time();
          for (int iter = 0; iter < iterations; iter++) {
              cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans,
                          n, n, n, alpha, A, n, B, n, beta, C, n);
          }
          double elapsed = get_time() - start;

          double flops = 2.0 * n * n * n * iterations;
          double gflops = flops / elapsed / 1e9;

          printf("  Total time: %.3f s\n", elapsed);
          printf("  Avg per iteration: %.3f s\n", elapsed / iterations);
          printf("  Performance: %.2f GFLOPS\n", gflops);
          fflush(stdout);

          mkl_free(A); mkl_free(B); mkl_free(C);
      }

      void bench_lu(int n, int iterations) {
          printf("\n[LU] %dx%d factorization (%d iterations)\n", n, n, iterations);
          fflush(stdout);

          double *A_orig = (double*)mkl_malloc(n * n * sizeof(double), 64);
          double *A = (double*)mkl_malloc(n * n * sizeof(double), 64);
          int *ipiv = (int*)mkl_malloc(n * sizeof(int), 64);

          if (!A || !A_orig || !ipiv) { printf("  Memory allocation failed\n"); return; }

          for (int i = 0; i < n; i++) {
              for (int j = 0; j < n; j++) {
                  A_orig[i * n + j] = (double)rand() / RAND_MAX;
                  if (i == j) A_orig[i * n + j] += n;
              }
          }

          double start = get_time();
          for (int iter = 0; iter < iterations; iter++) {
              // Copy original matrix (LU destroys input)
              for (int i = 0; i < n * n; i++) A[i] = A_orig[i];
              LAPACKE_dgetrf(LAPACK_ROW_MAJOR, n, n, A, n, ipiv);
          }
          double elapsed = get_time() - start;

          double flops = (2.0/3.0) * n * n * n * iterations;
          printf("  Total time: %.3f s\n", elapsed);
          printf("  Avg per iteration: %.3f s\n", elapsed / iterations);
          printf("  Performance: %.2f GFLOPS\n", flops / elapsed / 1e9);
          fflush(stdout);

          mkl_free(A); mkl_free(A_orig); mkl_free(ipiv);
      }

      void bench_cholesky(int n, int iterations) {
          printf("\n[Cholesky] %dx%d factorization (%d iterations)\n", n, n, iterations);
          fflush(stdout);

          double *A_orig = (double*)mkl_malloc(n * n * sizeof(double), 64);
          double *A = (double*)mkl_malloc(n * n * sizeof(double), 64);

          if (!A || !A_orig) { printf("  Memory allocation failed\n"); return; }

          // Create SPD matrix
          for (int i = 0; i < n; i++) {
              for (int j = 0; j <= i; j++) {
                  double val = (double)rand() / RAND_MAX;
                  A_orig[i * n + j] = val;
                  A_orig[j * n + i] = val;
                  if (i == j) A_orig[i * n + j] += n;
              }
          }

          double start = get_time();
          for (int iter = 0; iter < iterations; iter++) {
              for (int i = 0; i < n * n; i++) A[i] = A_orig[i];
              LAPACKE_dpotrf(LAPACK_ROW_MAJOR, 'L', n, A, n);
          }
          double elapsed = get_time() - start;

          double flops = (1.0/3.0) * n * n * n * iterations;
          printf("  Total time: %.3f s\n", elapsed);
          printf("  Avg per iteration: %.3f s\n", elapsed / iterations);
          printf("  Performance: %.2f GFLOPS\n", flops / elapsed / 1e9);
          fflush(stdout);

          mkl_free(A); mkl_free(A_orig);
      }

      void bench_fft(int n, int iterations) {
          printf("\n[FFT] %d-point complex FFT (%d iterations)\n", n, iterations);
          fflush(stdout);

          MKL_Complex16 *x = (MKL_Complex16*)mkl_malloc(n * sizeof(MKL_Complex16), 64);
          if (!x) { printf("  Memory allocation failed\n"); return; }

          for (int i = 0; i < n; i++) {
              x[i].real = (double)rand() / RAND_MAX;
              x[i].imag = (double)rand() / RAND_MAX;
          }

          DFTI_DESCRIPTOR_HANDLE desc;
          DftiCreateDescriptor(&desc, DFTI_DOUBLE, DFTI_COMPLEX, 1, (MKL_LONG)n);
          DftiCommitDescriptor(desc);

          // Warm-up
          DftiComputeForward(desc, x);

          double start = get_time();
          for (int i = 0; i < iterations; i++) {
              DftiComputeForward(desc, x);
          }
          double elapsed = get_time() - start;

          double flops = 5.0 * n * log2((double)n) * iterations;
          printf("  Total time: %.3f s\n", elapsed);
          printf("  Avg per FFT: %.6f s\n", elapsed / iterations);
          printf("  Performance: %.2f GFLOPS\n", flops / elapsed / 1e9);
          fflush(stdout);

          DftiFreeDescriptor(&desc);
          mkl_free(x);
      }

      int main() {
          srand(42);

          printf("============================================================\n");
          printf("Intel MKL Benchmark Suite\n");
          printf("============================================================\n");
          printf("MKL threads: %d\n", mkl_get_max_threads());
          printf("Running extended benchmarks...\n");
          fflush(stdout);

          printf("\n------------------------------------------------------------\n");
          printf("DGEMM BENCHMARKS\n");
          printf("------------------------------------------------------------\n");

          bench_dgemm(1000, 50);
          bench_dgemm(2000, 20);
          bench_dgemm(4000, 5);
          bench_dgemm(6000, 2);

          printf("\n------------------------------------------------------------\n");
          printf("LAPACK BENCHMARKS\n");
          printf("------------------------------------------------------------\n");

          bench_lu(2000, 10);
          bench_lu(4000, 3);
          bench_cholesky(2000, 10);
          bench_cholesky(4000, 3);

          printf("\n------------------------------------------------------------\n");
          printf("FFT BENCHMARKS\n");
          printf("------------------------------------------------------------\n");

          bench_fft(1 << 16, 500);   // 64K points
          bench_fft(1 << 18, 100);   // 256K points
          bench_fft(1 << 20, 50);    // 1M points
          bench_fft(1 << 22, 10);    // 4M points

          printf("\n============================================================\n");
          printf("MKL Benchmark Complete!\n");
          printf("============================================================\n");

          return 0;
      }
      CEOF

      echo "Compiling..."

      # Use icx (Intel's newer compiler) or fall back to gcc
      if command -v icx &> /dev/null; then
          icx -O3 -xHost -qopenmp mkl_bench.c -o mkl_bench \
              -I${MKLROOT}/include \
              -L${MKLROOT}/lib/intel64 \
              -lmkl_intel_lp64 -lmkl_intel_thread -lmkl_core \
              -liomp5 -lpthread -lm -ldl
      else
          gcc -O3 -march=native -fopenmp mkl_bench.c -o mkl_bench \
              -I${MKLROOT}/include \
              -L${MKLROOT}/lib/intel64 \
              -Wl,--no-as-needed -lmkl_intel_lp64 -lmkl_gnu_thread -lmkl_core \
              -lgomp -lpthread -lm -ldl
      fi

      if [ ! -f mkl_bench ]; then
          echo "Compilation failed!"
          exit 1
      fi

      echo "Running benchmark..."
      echo ""
      ./mkl_bench
